import { RealTimeMessage, ThreadEvent, ThreadEventSchema } from "@/app/schemas/realitme";
import { orpc } from "@/lib/orpc";
import { useQueryClient } from "@tanstack/react-query";
import { usePartySocket } from "partysocket/react";
import { createContext, ReactNode, useContext, useMemo } from "react";

interface ThreadRealtimeProviderProps{
    children : ReactNode,
    threadId: string;
}

type ThreadRealtimeContextValue = {
    send: (event: ThreadEvent) => void;
}


const ThreadRealtimeContext = createContext<null | ThreadRealtimeContextValue>(null);

export function ThreadRealtimeProvider({children,threadId}: ThreadRealtimeProviderProps){

    const queryClient = useQueryClient();

    type ThreadListOption = ReturnType<typeof orpc.message.thread.list.queryOptions>
    
    type ThreadQueryData = Awaited<ReturnType<ThreadListOption["queryFn"]>>
    const socket = usePartySocket({
        host:'https://teamflow-chat-realtime.ronygral1.workers.dev',
        room : `thread-${threadId}`,
        party:"chat",

        onMessage(e){
            try{
                const parsed = JSON.parse(e.data)
                const result = ThreadEventSchema.safeParse(parsed);

                if(!result.success){
                    console.log('invalid thread event');
                    return;
                }
                
                const evt = result.data;

                if(evt.type === 'thread:reply:created'){

                    const replyObj = evt.payload.reply as RealTimeMessage
                    //Use tje same key generated by orpc 
                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: {messageId: threadId}
                    });
                    
                    queryClient.setQueryData<ThreadQueryData>(
                        listOptions.queryKey,
                        (old) =>{
                            if(!old) return old;

                        

                        const reply = {

                            reactions : Array.isArray(replyObj.reactions) ? replyObj.reactions : [], ...replyObj


                        }as ThreadQueryData["messages"][number]

                        return {
                            ...old,
                            messages: [...old.messages, reply]
                        }
                    }
                    
                    )
                    return;
                    


                }
                if(evt.type === 'thread:reaction:updated'){
                        const {messageId, reactions, threadId : tid } = evt.payload


                        if(tid !== threadId){
                            return;
                        }
                        const listOptions = orpc.message.thread.list.queryOptions({
                            input : {messageId: threadId}
                        });

                        queryClient.setQueryData(
                            listOptions.queryKey,
                            (old) => {
                                if(!old) return old;

                                if (messageId === threadId){
                                    return{
                                        ...old,
                                        parent:{...old.parent, reactions},

                                    };
                                }

                                return {
                                    ...old,
                                    messages: old.messages.map((m) => m.id === messageId ? { ...m, reactions}: m)
                                }
                            }
                        );
                        return;
                    }
                



            }catch{

                console.log("something went wrong")

            }
        }

         
        

    });

    const value = useMemo<ThreadRealtimeContextValue>(()=> {
            return {
                send : (event) => {
                    socket.send(JSON.stringify(event));
                },
    
            }
        }, [socket]);

        return (
            <ThreadRealtimeContext.Provider value = {value}>
            {children}
            </ThreadRealtimeContext.Provider>
        );

    
}
export function useThreadRealtime(){
    const ctx = useContext(ThreadRealtimeContext );
    
        if(!ctx) {
            throw new Error(
                "useThreadRealtime must be used within a threadrealtimeProvider"
            )
        }
    
        return ctx;
}

export function useOptionalThreadRealtime(): ThreadRealtimeContextValue | null{
    return useContext(ThreadRealtimeContext);
}